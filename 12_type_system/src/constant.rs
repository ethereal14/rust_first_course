// 类型系统基本概念与分类
// 类型系统其实就是，对类型进行定义、检查和处理的系统。

// 按定义后类型是否可以隐式转换，可以分为强类型和弱类型。
// Rust 不同类型间不能自动转换，所以是强类型语言，
// 而 C / C++ / JavaScript 会自动转换，是弱类型语言。

// 按类型检查的时机，在编译时检查还是运行时检查，
// 可以分为静态类型系统和动态类型系统。
// 对于静态类型系统，还可以进一步分为显式静态和隐式静态，
// Rust / Java / Swift 等语言都是显式静态语言，
// 而 Haskell 是隐式静态语言

// 在类型系统中，多态是一个非常重要的思想，
// 它是指在使用相同的接口时，不同类型的对象，
// 会采用不同的实现。

// 对于动态类型系统，多态通过鸭子类型（duck typing）实现；
// 而对于静态类型系统，多态可以通过参数多态（parametric polymorphism）、
// 特设多态（adhoc polymorphism）和子类型多态（subtype polymorphism）实现。

// 参数多态是指，代码操作的类型是一个满足某些约束的参数，而非具体的类型。
// 特设多态是指同一种行为有多个不同实现的多态。
// 比如加法，可以 1+1，也可以是 “abc” + “cde”、matrix1 + matrix2、甚至 matrix1 + vector1。
// 在面向对象编程语言中，特设多态一般指函数的重载。

// 子类型多态是指，在运行时，子类型可以被当成父类型使用。
// 在 Rust 中，参数多态通过泛型来支持、特设多态通过 trait 来支持、
// 子类型多态可以用 trait object 来支持，我们待会讲参数多态，下节课再详细讲另外两个。


// Rust 类型系统
// 按刚才不同阶段的分类，在定义时， Rust 不允许类型的隐式转换，也就是说，Rust 是强类型语言；
// 同时在检查时，Rust 使用了静态类型系统，在编译期保证类型的正确。
// 强类型加静态类型，使得 Rust 是一门类型安全的语言。

// Rust 下的内存安全更严格：代码只能按照被允许的方法和被允许的权限，访问它被授权访问的内存。


// 有些情况下,即使上下文中含有类型的信息，也需要开发者为变量提供类型，比如常量和静态变量的定义
const PI: f64 = 3.1415926;
static E: f32 = 2.71828;

fn main() {
    const V: u32 = 10;
    static V1: &str = "hello";
    println!("PI: {}, E: {}, V {}, V1: {}", PI, E, V, V1);
}