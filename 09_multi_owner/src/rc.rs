use std::rc::Rc;
// 智能指针：Rc、Arc（Atomic reference counter）
fn main() {
    // 我们先看 Rc。对某个数据结构 T，我们可以创建引用计数 Rc，使其有多个所有者。
    // Rc 会把对应的数据结构创建在堆上，我们在第二讲谈到过，
    // 堆是唯一可以让动态创建的数据被到处使用的内存。
    let a = Rc::new(1);

    // 对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数。
    // 而当一个 Rc 结构离开作用域被 drop() 时，也只会减少其引用计数，
    // 直到引用计数为零，才会真正清除对应的内存。
    let b = a.clone();

    let c = a.clone();

    // 在所有权模型下，堆内存的生命周期，和创建它的栈内存的生命周期保持一致
    // Rust 提供的方式是 Box::leak()
    // 创建不受栈内存控制的堆内存，从而绕过编译时的所有权规则
    // Box 是 Rust 下的智能指针，它可以强制把任何数据结构创建在堆上，
    // 然后在栈上放一个指针指向这个数据结构，但此时堆内存的生命周期仍然是受控的，跟栈上的指针一致

    // Box::leak()，顾名思义，它创建的对象，从堆内存上泄漏出去，不受栈内存控制，
    // 是一个自由的、生命周期可以大到和整个进程的生命周期一致的对象。

    // 有了 Box::leak()，我们就可以跳出 Rust 编译器的静态检查，保证 Rc 指向的堆内存，
    // 有最大的生命周期，然后我们再通过引用计数，在合适的时机，结束这段内存的生命周期
}
